"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FarmTech Solutions - Integra√ß√£o Meteorol√≥gica (IR AL√âM 1)
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

OBJETIVO: Integrar dados meteorol√≥gicos de APIs p√∫blicas para otimizar irriga√ß√£o

FUNCIONALIDADES:
- Consulta API OpenWeatherMap para previs√£o de chuva
- Suspende irriga√ß√£o automaticamente se h√° previs√£o de chuva
- Economia de recursos h√≠dricos
- Comunica√ß√£o via Serial com ESP32
- Modo manual para inser√ß√£o de dados via Serial Monitor

AUTORES: Grupo 59 FIAP
DATA: Outubro 2025
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""

import requests
import json
import serial
import time
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional

class WeatherAPI:
    """Classe para integra√ß√£o com OpenWeatherMap API"""
    
    def __init__(self, api_key: str = None, city: str = "S√£o Paulo", country: str = "BR"):
        """
        Inicializa a classe WeatherAPI
        
        Args:
            api_key: Chave da API OpenWeatherMap (obter em openweathermap.org)
            city: Cidade para consulta meteorol√≥gica
            country: C√≥digo do pa√≠s (BR para Brasil)
        """
        self.api_key = api_key or os.getenv('OPENWEATHER_API_KEY')
        self.city = city
        self.country = country
        self.base_url = "http://api.openweathermap.org/data/2.5"
        self.serial_port = None
        
        # Cache para evitar muitas consultas √† API
        self.last_weather_data = None
        self.last_update = None
        self.cache_duration = 600  # 10 minutos
        
        print(f"üå§Ô∏è WeatherAPI inicializada para {city}, {country}")
        if not self.api_key:
            print("‚ö†Ô∏è API Key n√£o encontrada! Configure OPENWEATHER_API_KEY ou use modo manual")
    
    def get_current_weather(self) -> Optional[Dict]:
        """
        Obt√©m dados meteorol√≥gicos atuais
        
        Returns:
            Dict com dados do clima ou None se erro
        """
        if not self.api_key:
            print("‚ùå API Key n√£o configurada!")
            return None
        
        # Verifica cache
        if self._is_cache_valid():
            print("üìã Usando dados do cache...")
            return self.last_weather_data
        
        try:
            url = f"{self.base_url}/weather"
            params = {
                'q': f"{self.city},{self.country}",
                'appid': self.api_key,
                'units': 'metric',
                'lang': 'pt_br'
            }
            
            print(f"üåê Consultando API para {self.city}...")
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            # Processa dados
            weather_data = {
                'temperatura': data['main']['temp'],
                'umidade': data['main']['humidity'],
                'pressao': data['main']['pressure'],
                'descricao': data['weather'][0]['description'],
                'vento_velocidade': data['wind']['speed'],
                'nuvens': data['clouds']['all'],
                'cidade': data['name'],
                'timestamp': datetime.now().isoformat()
            }
            
            # Atualiza cache
            self.last_weather_data = weather_data
            self.last_update = datetime.now()
            
            print("‚úÖ Dados meteorol√≥gicos obtidos com sucesso!")
            return weather_data
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Erro na consulta √† API: {e}")
            return None
        except Exception as e:
            print(f"‚ùå Erro inesperado: {e}")
            return None
    
    def get_rain_forecast(self, hours: int = 12) -> Optional[Dict]:
        """
        Obt√©m previs√£o de chuva para pr√≥ximas horas
        
        Args:
            hours: N√∫mero de horas para previs√£o (m√°ximo 48h)
            
        Returns:
            Dict com previs√£o de chuva
        """
        if not self.api_key:
            print("‚ùå API Key n√£o configurada!")
            return None
        
        try:
            url = f"{self.base_url}/forecast"
            params = {
                'q': f"{self.city},{self.country}",
                'appid': self.api_key,
                'units': 'metric',
                'lang': 'pt_br'
            }
            
            print(f"üåßÔ∏è Consultando previs√£o de chuva para {hours}h...")
            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            # Analisa pr√≥ximas horas
            rain_forecast = {
                'vai_chover': False,
                'probabilidade_maxima': 0,
                'quantidade_chuva_mm': 0,
                'horas_ate_chuva': None,
                'previsoes': []
            }
            
            now = datetime.now()
            target_time = now + timedelta(hours=hours)
            
            for item in data['list']:
                forecast_time = datetime.fromtimestamp(item['dt'])
                
                if forecast_time <= target_time:
                    # Verifica se h√° chuva prevista
                    weather_main = item['weather'][0]['main'].lower()
                    has_rain = 'rain' in weather_main or 'drizzle' in weather_main
                    
                    # Quantidade de chuva (se dispon√≠vel)
                    rain_mm = 0
                    if 'rain' in item and '3h' in item['rain']:
                        rain_mm = item['rain']['3h']
                    
                    # Probabilidade (aproximada baseada em umidade e nuvens)
                    probability = min(item['clouds']['all'] + item['main']['humidity']) / 2
                    
                    if has_rain or rain_mm > 0:
                        rain_forecast['vai_chover'] = True
                        rain_forecast['quantidade_chuva_mm'] += rain_mm
                        
                        if not rain_forecast['horas_ate_chuva']:
                            rain_forecast['horas_ate_chuva'] = (forecast_time - now).total_seconds() / 3600
                    
                    if probability > rain_forecast['probabilidade_maxima']:
                        rain_forecast['probabilidade_maxima'] = probability
                    
                    rain_forecast['previsoes'].append({
                        'horario': forecast_time.strftime('%H:%M'),
                        'temperatura': item['main']['temp'],
                        'umidade': item['main']['humidity'],
                        'descricao': item['weather'][0]['description'],
                        'chuva_mm': rain_mm,
                        'probabilidade': probability
                    })
            
            print(f"‚úÖ Previs√£o obtida: {'Chuva prevista' if rain_forecast['vai_chover'] else 'Sem chuva'}")
            return rain_forecast
            
        except Exception as e:
            print(f"‚ùå Erro ao obter previs√£o: {e}")
            return None
    
    def should_skip_irrigation(self, threshold_mm: float = 2.0, threshold_hours: int = 6) -> Dict:
        """
        Decide se deve suspender a irriga√ß√£o baseado na previs√£o
        
        Args:
            threshold_mm: Quantidade m√≠nima de chuva (mm) para suspender
            threshold_hours: Horas para considerar na previs√£o
            
        Returns:
            Dict com decis√£o e justificativa
        """
        print(f"\nü§î Analisando se deve suspender irriga√ß√£o...")
        print(f"   Limites: {threshold_mm}mm em {threshold_hours}h")
        
        # Obt√©m previs√£o
        forecast = self.get_rain_forecast(threshold_hours)
        
        decision = {
            'suspender_irrigacao': False,
            'motivo': 'Sem previs√£o de chuva significativa',
            'previsao': forecast
        }
        
        if forecast and forecast['vai_chover']:
            rain_amount = forecast['quantidade_chuva_mm']
            hours_to_rain = forecast['horas_ate_chuva']
            
            if rain_amount >= threshold_mm:
                decision['suspender_irrigacao'] = True
                decision['motivo'] = f"Chuva prevista: {rain_amount:.1f}mm em {hours_to_rain:.1f}h"
            elif forecast['probabilidade_maxima'] > 80:
                decision['suspender_irrigacao'] = True
                decision['motivo'] = f"Alta probabilidade de chuva: {forecast['probabilidade_maxima']:.0f}%"
        
        print(f"   Decis√£o: {'üö´ Suspender' if decision['suspender_irrigacao'] else '‚úÖ Continuar'}")
        print(f"   Motivo: {decision['motivo']}")
        
        return decision
    
    def _is_cache_valid(self) -> bool:
        """Verifica se o cache ainda √© v√°lido"""
        if not self.last_update or not self.last_weather_data:
            return False
        
        time_diff = (datetime.now() - self.last_update).total_seconds()
        return time_diff < self.cache_duration
    
    def connect_serial(self, port: str, baudrate: int = 115200) -> bool:
        """
        Conecta √† porta serial do ESP32
        
        Args:
            port: Porta serial (ex: 'COM3' no Windows, '/dev/ttyUSB0' no Linux)
            baudrate: Taxa de transmiss√£o
            
        Returns:
            True se conectou com sucesso
        """
        try:
            self.serial_port = serial.Serial(port, baudrate, timeout=1)
            time.sleep(2)  # Aguarda estabiliza√ß√£o
            print(f"‚úÖ Conectado √† porta serial {port}")
            return True
        except Exception as e:
            print(f"‚ùå Erro ao conectar serial: {e}")
            return False
    
    def send_weather_data(self, data: Dict) -> bool:
        """
        Envia dados meteorol√≥gicos via serial para ESP32
        
        Args:
            data: Dados meteorol√≥gicos para enviar
            
        Returns:
            True se enviou com sucesso
        """
        if not self.serial_port:
            print("‚ùå Porta serial n√£o conectada!")
            return False
        
        try:
            # Formato: WEATHER:temp,humid,pressure,rain_forecast
            current = self.get_current_weather()
            forecast = self.get_rain_forecast(6)
            
            if current and forecast:
                message = f"WEATHER:{current['temperatura']:.1f},{current['umidade']},{current['pressao']:.0f},{int(forecast['vai_chover'])}\n"
                
                self.serial_port.write(message.encode())
                self.serial_port.flush()
                
                print(f"üì§ Enviado: {message.strip()}")
                return True
            else:
                print("‚ùå Dados meteorol√≥gicos n√£o dispon√≠veis")
                return False
                
        except Exception as e:
            print(f"‚ùå Erro ao enviar dados: {e}")
            return False
    
    def listen_for_requests(self):
        """
        Escuta requisi√ß√µes do ESP32 e responde com dados meteorol√≥gicos
        """
        if not self.serial_port:
            print("‚ùå Porta serial n√£o conectada!")
            return
        
        print("üëÇ Aguardando requisi√ß√µes do ESP32...")
        print("   Envie 'GET_WEATHER' do ESP32 para receber dados")
        print("   Pressione Ctrl+C para parar\n")
        
        try:
            while True:
                if self.serial_port.in_waiting > 0:
                    message = self.serial_port.readline().decode().strip()
                    
                    if message == "GET_WEATHER":
                        print("üì• Requisi√ß√£o recebida do ESP32")
                        self.send_weather_data({})
                    elif message:
                        print(f"üì® ESP32: {message}")
                
                time.sleep(0.1)
                
        except KeyboardInterrupt:
            print("\nüõë Parando escuta...")
        except Exception as e:
            print(f"‚ùå Erro na comunica√ß√£o: {e}")
    
    def print_weather_report(self):
        """Exibe relat√≥rio meteorol√≥gico completo"""
        print("\n" + "="*70)
        print("üå§Ô∏è RELAT√ìRIO METEOROL√ìGICO - FARMTECH SOLUTIONS")
        print("="*70)
        
        # Dados atuais
        current = self.get_current_weather()
        if current:
            print(f"\nüìç Localiza√ß√£o: {current['cidade']}")
            print(f"üå°Ô∏è Temperatura: {current['temperatura']:.1f}¬∞C")
            print(f"üíß Umidade: {current['umidade']}%")
            print(f"üîΩ Press√£o: {current['pressao']:.0f} hPa")
            print(f"‚òÅÔ∏è Condi√ß√µes: {current['descricao']}")
            print(f"üí® Vento: {current['vento_velocidade']:.1f} m/s")
            print(f"‚òÅÔ∏è Nuvens: {current['nuvens']}%")
        
        # Previs√£o de chuva
        forecast = self.get_rain_forecast(12)
        if forecast:
            print(f"\nüåßÔ∏è PREVIS√ÉO DE CHUVA (pr√≥ximas 12h):")
            print(f"   Status: {'Chuva prevista ‚òî' if forecast['vai_chover'] else 'Sem chuva ‚òÄÔ∏è'}")
            
            if forecast['vai_chover']:
                print(f"   Quantidade: {forecast['quantidade_chuva_mm']:.1f} mm")
                if forecast['horas_ate_chuva']:
                    print(f"   In√≠cio: {forecast['horas_ate_chuva']:.1f} horas")
            
            print(f"   Probabilidade m√°xima: {forecast['probabilidade_maxima']:.0f}%")
        
        # Decis√£o de irriga√ß√£o
        decision = self.should_skip_irrigation()
        print(f"\nüíß DECIS√ÉO DE IRRIGA√á√ÉO:")
        print(f"   A√ß√£o: {'üö´ SUSPENDER' if decision['suspender_irrigacao'] else '‚úÖ CONTINUAR'}")
        print(f"   Motivo: {decision['motivo']}")
        
        print("="*70)
        print(f"üïê Atualizado em: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        print("="*70)

def main():
    """Fun√ß√£o principal para teste e demonstra√ß√£o"""
    print("üöÄ Iniciando FarmTech Weather Integration...")
    
    # Configura√ß√£o
    weather = WeatherAPI(
        city="S√£o Paulo",
        country="BR"
    )
    
    # Exibe relat√≥rio meteorol√≥gico
    weather.print_weather_report()
    
    # Op√ß√£o de comunica√ß√£o serial (descomente para usar)
    # weather.connect_serial('COM3')  # Ajustar porta conforme necess√°rio
    # weather.listen_for_requests()

if __name__ == "__main__":
    main()