"""
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
FarmTech Solutions - Comunica√ß√£o Serial com ESP32
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

Script para comunica√ß√£o entre Python (dados meteorol√≥gicos) e ESP32
Envia comandos via Serial Monitor para controle de irriga√ß√£o baseado no clima

COMANDOS SUPORTADOS pelo ESP32:
- GET_WEATHER: Solicita dados meteorol√≥gicos atuais
- SET_WEATHER:temp,humid,pressure,rain: Define dados manualmente
- RAIN_ALERT:1/0: Alerta de chuva (1=chuva, 0=sem chuva)
- SUSPEND_IRRIGATION: Suspende irriga√ß√£o por clima

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""

import serial
import serial.tools.list_ports
import time
import json
from datetime import datetime
from weather_api import WeatherAPI

class SerialCommunicator:
    """Classe para comunica√ß√£o serial com ESP32"""
    
    def __init__(self, baudrate: int = 115200):
        self.serial_port = None
        self.baudrate = baudrate
        self.weather_api = WeatherAPI()
        
    def list_available_ports(self):
        """Lista todas as portas seriais dispon√≠veis"""
        ports = serial.tools.list_ports.comports()
        
        print("üîå Portas seriais dispon√≠veis:")
        if not ports:
            print("   Nenhuma porta encontrada")
            return []
        
        available_ports = []
        for i, port in enumerate(ports):
            print(f"   {i+1}. {port.device} - {port.description}")
            available_ports.append(port.device)
        
        return available_ports
    
    def connect(self, port: str = None) -> bool:
        """
        Conecta √† porta serial do ESP32
        
        Args:
            port: Porta espec√≠fica ou None para sele√ß√£o autom√°tica
            
        Returns:
            True se conectou com sucesso
        """
        if not port:
            ports = self.list_available_ports()
            if not ports:
                print("‚ùå Nenhuma porta serial encontrada!")
                return False
            
            # Tenta conectar automaticamente na primeira porta
            port = ports[0]
            print(f"üîÑ Tentando conectar automaticamente em {port}...")
        
        try:
            self.serial_port = serial.Serial(port, self.baudrate, timeout=1)
            time.sleep(2)  # Aguarda ESP32 reinicializar
            
            # Testa conex√£o
            self.send_command("PING")
            print(f"‚úÖ Conectado com sucesso em {port}")
            return True
            
        except Exception as e:
            print(f"‚ùå Erro ao conectar em {port}: {e}")
            return False
    
    def disconnect(self):
        """Desconecta da porta serial"""
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()
            print("üîå Desconectado da porta serial")
    
    def send_command(self, command: str, wait_response: bool = True) -> str:
        """
        Envia comando para ESP32
        
        Args:
            command: Comando a ser enviado
            wait_response: Se deve aguardar resposta
            
        Returns:
            Resposta do ESP32 ou string vazia
        """
        if not self.serial_port or not self.serial_port.is_open:
            print("‚ùå Porta serial n√£o conectada!")
            return ""
        
        try:
            # Envia comando
            message = f"{command}\n"
            self.serial_port.write(message.encode())
            self.serial_port.flush()
            
            print(f"üì§ Enviado: {command}")
            
            if wait_response:
                # Aguarda resposta (timeout 5s)
                start_time = time.time()
                while time.time() - start_time < 5:
                    if self.serial_port.in_waiting > 0:
                        response = self.serial_port.readline().decode().strip()
                        if response:
                            print(f"üì• Resposta: {response}")
                            return response
                    time.sleep(0.1)
                
                print("‚è∞ Timeout aguardando resposta")
            
            return ""
            
        except Exception as e:
            print(f"‚ùå Erro ao enviar comando: {e}")
            return ""
    
    def send_weather_data(self, manual_data: dict = None) -> bool:
        """
        Envia dados meteorol√≥gicos para ESP32
        
        Args:
            manual_data: Dados manuais ou None para usar API
            
        Returns:
            True se enviou com sucesso
        """
        try:
            if manual_data:
                # Usa dados fornecidos manualmente
                temp = manual_data.get('temperatura', 25.0)
                humid = manual_data.get('umidade', 60)
                pressure = manual_data.get('pressao', 1013)
                rain = 1 if manual_data.get('vai_chover', False) else 0
            else:
                # Obt√©m dados da API
                current = self.weather_api.get_current_weather()
                forecast = self.weather_api.get_rain_forecast(6)
                
                if not current or not forecast:
                    print("‚ùå N√£o foi poss√≠vel obter dados meteorol√≥gicos")
                    return False
                
                temp = current['temperatura']
                humid = current['umidade']
                pressure = current['pressao']
                rain = 1 if forecast['vai_chover'] else 0
            
            # Formato: SET_WEATHER:temperatura,umidade,press√£o,chuva
            command = f"SET_WEATHER:{temp:.1f},{humid},{pressure:.0f},{rain}"
            response = self.send_command(command)
            
            return "OK" in response.upper()
            
        except Exception as e:
            print(f"‚ùå Erro ao enviar dados meteorol√≥gicos: {e}")
            return False
    
    def send_rain_alert(self, rain_predicted: bool) -> bool:
        """
        Envia alerta de chuva para ESP32
        
        Args:
            rain_predicted: True se h√° previs√£o de chuva
            
        Returns:
            True se enviou com sucesso
        """
        command = f"RAIN_ALERT:{1 if rain_predicted else 0}"
        response = self.send_command(command)
        return "OK" in response.upper()
    
    def request_irrigation_status(self) -> dict:
        """
        Solicita status atual da irriga√ß√£o do ESP32
        
        Returns:
            Dict com status da irriga√ß√£o
        """
        response = self.send_command("GET_STATUS")
        
        try:
            # Espera resposta no formato: STATUS:relay,humidity,temperature,npk_ok
            if response.startswith("STATUS:"):
                parts = response.split(":")[1].split(",")
                
                return {
                    'irrigacao_ligada': parts[0] == "1",
                    'umidade_solo': float(parts[1]),
                    'temperatura': float(parts[2]),
                    'npk_adequado': parts[3] == "1",
                    'timestamp': datetime.now().isoformat()
                }
        except Exception as e:
            print(f"‚ùå Erro ao processar status: {e}")
        
        return {}
    
    def interactive_mode(self):
        """
        Modo interativo para comunica√ß√£o com ESP32
        """
        if not self.serial_port or not self.serial_port.is_open:
            print("‚ùå Conecte √† porta serial primeiro!")
            return
        
        print("\n" + "="*60)
        print("ü§ñ MODO INTERATIVO - COMUNICA√á√ÉO COM ESP32")
        print("="*60)
        print("Comandos dispon√≠veis:")
        print("  weather    - Envia dados meteorol√≥gicos via API")
        print("  manual     - Envia dados meteorol√≥gicos manuais")
        print("  rain       - Envia alerta de chuva")
        print("  status     - Solicita status do ESP32")
        print("  ping       - Testa conex√£o")
        print("  listen     - Escuta mensagens do ESP32")
        print("  quit       - Sair")
        print("="*60)
        
        try:
            while True:
                command = input("\nüíª Comando: ").strip().lower()
                
                if command == "quit" or command == "q":
                    break
                elif command == "weather":
                    print("üå§Ô∏è Enviando dados meteorol√≥gicos via API...")
                    success = self.send_weather_data()
                    print("‚úÖ Enviado!" if success else "‚ùå Falhou!")
                
                elif command == "manual":
                    print("üìù Inserindo dados meteorol√≥gicos manuais:")
                    try:
                        temp = float(input("   Temperatura (¬∞C): "))
                        humid = int(input("   Umidade (%): "))
                        pressure = float(input("   Press√£o (hPa): "))
                        rain = input("   Previs√£o de chuva (s/n): ").lower().startswith('s')
                        
                        manual_data = {
                            'temperatura': temp,
                            'umidade': humid,
                            'pressao': pressure,
                            'vai_chover': rain
                        }
                        
                        success = self.send_weather_data(manual_data)
                        print("‚úÖ Enviado!" if success else "‚ùå Falhou!")
                        
                    except ValueError:
                        print("‚ùå Valores inv√°lidos!")
                
                elif command == "rain":
                    rain_alert = input("   Alerta de chuva (s/n): ").lower().startswith('s')
                    success = self.send_rain_alert(rain_alert)
                    print("‚úÖ Enviado!" if success else "‚ùå Falhou!")
                
                elif command == "status":
                    print("üìä Solicitando status...")
                    status = self.request_irrigation_status()
                    if status:
                        print("üìã Status atual:")
                        print(f"   üö∞ Irriga√ß√£o: {'LIGADA' if status['irrigacao_ligada'] else 'DESLIGADA'}")
                        print(f"   üíß Umidade solo: {status['umidade_solo']:.1f}%")
                        print(f"   üå°Ô∏è Temperatura: {status['temperatura']:.1f}¬∞C")
                        print(f"   üß™ NPK adequado: {'SIM' if status['npk_adequado'] else 'N√ÉO'}")
                    else:
                        print("‚ùå N√£o foi poss√≠vel obter status")
                
                elif command == "ping":
                    response = self.send_command("PING")
                    print("üèì Pong!" if "PONG" in response.upper() else "‚ùå Sem resposta")
                
                elif command == "listen":
                    print("üëÇ Escutando ESP32... (Ctrl+C para parar)")
                    try:
                        while True:
                            if self.serial_port.in_waiting > 0:
                                message = self.serial_port.readline().decode().strip()
                                if message:
                                    print(f"üì® ESP32: {message}")
                            time.sleep(0.1)
                    except KeyboardInterrupt:
                        print("\nüõë Parando escuta...")
                
                else:
                    print("‚ùå Comando n√£o reconhecido!")
        
        except KeyboardInterrupt:
            print("\nüõë Saindo do modo interativo...")

def main():
    """Fun√ß√£o principal"""
    print("üöÄ FarmTech Serial Communication")
    
    comm = SerialCommunicator()
    
    # Lista portas dispon√≠veis
    ports = comm.list_available_ports()
    
    if ports:
        # Tenta conectar
        if comm.connect():
            # Inicia modo interativo
            comm.interactive_mode()
        
        # Desconecta
        comm.disconnect()
    else:
        print("‚ùå Nenhuma porta serial encontrada!")
        print("üí° Verifique se o ESP32 est√° conectado via USB")

if __name__ == "__main__":
    main()