# Integra√ß√£o ESP32 (Cap 1) ‚Üî Python (Cap 6)

## üîó Arquitetura de Comunica√ß√£o

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CAMADA F√çSICA (Cap 1)                     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  NPK     ‚îÇ  ‚îÇ   LDR    ‚îÇ  ‚îÇ  DHT22   ‚îÇ  ‚îÇ  Relay   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ Buttons  ‚îÇ  ‚îÇ  (pH)    ‚îÇ  ‚îÇ (Temp/   ‚îÇ  ‚îÇ (Bomba)  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ GPIO 2,4,5‚îÇ  ‚îÇ GPIO 34  ‚îÇ  ‚îÇ Umid)    ‚îÇ  ‚îÇ GPIO 18  ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ                    ‚îÇESP32 DevKit v1‚îÇ                        ‚îÇ
‚îÇ                    ‚îÇ  FarmTech.ino ‚îÇ                        ‚îÇ
‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ Serial USB (115200 baud)
                            ‚îÇ JSON Format
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    CAMADA SOFTWARE (Cap 6)                   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ          Python Serial Reader (PySerial)              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ L√™ dados do ESP32 via COM/ttyUSB                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Parse JSON: {'temp': 26.5, 'umid': 40, 'ph': 6.2} ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                         ‚îÇ                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ       SensorMonitor.adicionar_leitura()              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Valida dados (ranges, tipos)                      ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Converte umidade ar ‚Üí solo (√ó0.8)                 ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Armazena em JSON/Oracle                           ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                         ‚îÇ                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ     IrrigacaoController.decidir_irrigacao()          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Aplica 6 condi√ß√µes de decis√£o                     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Registra hist√≥rico                                ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                         ‚îÇ                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ         Python Serial Writer (PySerial)              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Envia comando para ESP32: {"relay": 1} ou 0      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚îÇ Serial USB
                            ‚ñº
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îÇ ESP32 executa   ‚îÇ
                  ‚îÇ digitalWrite()  ‚îÇ
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üì° Protocolo de Comunica√ß√£o Serial

### Formato de Dados: JSON

#### ESP32 ‚Üí Python (Leitura de Sensores)

**Estrutura**:
```json
{
  "cultivo_id": 1,
  "timestamp": "2025-10-11T14:30:00",
  "temperatura": 26.5,
  "umidade_ar": 50.0,
  "umidade_solo": 40.0,
  "ph": 6.2,
  "npk": {
    "N": true,
    "P": true,
    "K": false
  },
  "relay_status": false
}
```

**C√≥digo ESP32** (FarmTech.ino):
```cpp
void enviarDadosSerial() {
    Serial.print("{");
    Serial.print("\"cultivo_id\":");
    Serial.print(cultivo_id);
    Serial.print(",\"timestamp\":\"");
    Serial.print(obterTimestamp());
    Serial.print("\",\"temperatura\":");
    Serial.print(temperaturaAr, 1);
    Serial.print(",\"umidade_ar\":");
    Serial.print(umidadeAr, 1);
    Serial.print(",\"umidade_solo\":");
    Serial.print(umidadeSolo, 1);
    Serial.print(",\"ph\":");
    Serial.print(phSolo, 1);
    Serial.print(",\"npk\":{\"N\":");
    Serial.print(nitrogenioOK ? "true" : "false");
    Serial.print(",\"P\":");
    Serial.print(fosforoOK ? "true" : "false");
    Serial.print(",\"K\":");
    Serial.print(potassioOK ? "true" : "false");
    Serial.print("},\"relay_status\":");
    Serial.print(releLigado ? "true" : "false");
    Serial.println("}");
}
```

#### Python ‚Üí ESP32 (Comando de Irriga√ß√£o)

**Estrutura**:
```json
{
  "command": "SET_RELAY",
  "value": 1
}
```

**C√≥digo Python**:
```python
import serial
import json

ser = serial.Serial('COM3', 115200, timeout=1)  # Ajuste porta

comando = {"command": "SET_RELAY", "value": 1}
ser.write((json.dumps(comando) + '\n').encode())
```

**C√≥digo ESP32** (recep√ß√£o):
```cpp
void loop() {
    if (Serial.available() > 0) {
        String comando = Serial.readStringUntil('\n');
        processarComando(comando);
    }
}

void processarComando(String json) {
    // Parse JSON (use biblioteca ArduinoJson)
    StaticJsonDocument<200> doc;
    deserializeJson(doc, json);
    
    if (doc["command"] == "SET_RELAY") {
        int valor = doc["value"];
        digitalWrite(RELE_PIN, valor == 1 ? HIGH : LOW);
        releLigado = (valor == 1);
    }
}
```

---

## üêç Script Python de Integra√ß√£o

### serial_reader.py (Recebe dados do ESP32)

```python
"""
Script de leitura cont√≠nua do ESP32 via Serial
Integra com FarmTech Solutions (Cap 6)
"""

import serial
import json
import time
from datetime import datetime
from sensor_monitor import SensorMonitor
from irrigacao_controller import IrrigacaoController
from cultivo_manager import CultivoManager

class ESP32Reader:
    """Leitor de dados do ESP32 via Serial"""
    
    def __init__(self, porta='COM3', baud=115200):
        """
        Inicializa conex√£o serial
        
        Args:
            porta (str): Porta COM (Windows) ou /dev/ttyUSB0 (Linux)
            baud (int): Baud rate (deve ser 115200)
        """
        self.porta = porta
        self.baud = baud
        self.serial = None
        self.sensor_mon = SensorMonitor()
        self.irrigacao_ctrl = IrrigacaoController()
        self.cultivo_mgr = CultivoManager()
        
        # Carrega dados existentes
        self.sensor_mon.carregar_json()
        self.irrigacao_ctrl.carregar_json()
        self.cultivo_mgr.carregar_json()
    
    def conectar(self):
        """Estabelece conex√£o serial"""
        try:
            self.serial = serial.Serial(self.porta, self.baud, timeout=1)
            print(f"‚úÖ Conectado √† porta {self.porta} (baud {self.baud})")
            time.sleep(2)  # Aguarda reset do Arduino
            return True
        except serial.SerialException as e:
            print(f"‚ùå Erro ao conectar: {e}")
            return False
    
    def desconectar(self):
        """Fecha conex√£o serial"""
        if self.serial and self.serial.is_open:
            self.serial.close()
            print("üîå Desconectado")
    
    def ler_linha(self):
        """
        L√™ uma linha da serial (JSON)
        
        Returns:
            dict: Dados parseados ou None se erro
        """
        if not self.serial or not self.serial.is_open:
            return None
        
        try:
            linha = self.serial.readline().decode('utf-8').strip()
            
            # Ignora linhas vazias ou que n√£o come√ßam com {
            if not linha or not linha.startswith('{'):
                return None
            
            # Parse JSON
            dados = json.loads(linha)
            return dados
            
        except (UnicodeDecodeError, json.JSONDecodeError) as e:
            print(f"‚ö†Ô∏è  Erro ao parsear linha: {e}")
            return None
    
    def processar_dados(self, dados):
        """
        Processa dados recebidos do ESP32
        
        Args:
            dados (dict): Dados JSON do ESP32
        """
        try:
            cultivo_id = dados.get('cultivo_id', 1)
            
            # Busca cultivo
            cultivo = self.cultivo_mgr.obter_cultivo(cultivo_id)
            if not cultivo:
                print(f"‚ö†Ô∏è  Cultivo {cultivo_id} n√£o encontrado")
                return
            
            # Registra leitura
            npk_ok = dados.get('npk', {'N': True, 'P': True, 'K': True})
            
            leitura_id = self.sensor_mon.adicionar_leitura(
                cultivo_id=cultivo_id,
                temperatura=dados['temperatura'],
                umidade_ar=dados['umidade_ar'],
                ph=dados['ph'],
                npk_ok=npk_ok
            )
            
            print(f"üìä Leitura {leitura_id} registrada:")
            print(f"   Temp: {dados['temperatura']}¬∞C")
            print(f"   Umidade solo: {dados['umidade_ar'] * 0.8:.1f}%")
            print(f"   pH: {dados['ph']}")
            print(f"   NPK: N={'‚úÖ' if npk_ok['N'] else '‚ùå'} "
                  f"P={'‚úÖ' if npk_ok['P'] else '‚ùå'} "
                  f"K={'‚úÖ' if npk_ok['K'] else '‚ùå'}")
            
            # Decide irriga√ß√£o
            leitura = self.sensor_mon.obter_leitura(leitura_id)
            resultado = self.irrigacao_ctrl.decidir_irrigacao(cultivo, leitura)
            
            if resultado['deve_irrigar']:
                print(f"üíßüíßüíß IRRIGA√á√ÉO NECESS√ÅRIA: {resultado['motivo']}")
                self.enviar_comando_relay(1)
            else:
                print(f"‚è∏Ô∏è‚è∏Ô∏è‚è∏Ô∏è IRRIGA√á√ÉO DESNECESS√ÅRIA: {resultado['motivo']}")
                self.enviar_comando_relay(0)
            
            # Registra decis√£o
            self.irrigacao_ctrl.registrar_irrigacao(
                cultivo_id=cultivo_id,
                leitura_id=leitura_id,
                acionado=resultado['deve_irrigar'],
                motivo=resultado['motivo']
            )
            
            print("‚îÄ" * 60)
            
        except Exception as e:
            print(f"‚ùå Erro ao processar dados: {e}")
    
    def enviar_comando_relay(self, valor):
        """
        Envia comando para ligar/desligar relay
        
        Args:
            valor (int): 1 = ligar, 0 = desligar
        """
        if not self.serial or not self.serial.is_open:
            return
        
        comando = {"command": "SET_RELAY", "value": valor}
        self.serial.write((json.dumps(comando) + '\n').encode())
        print(f"üì§ Comando enviado: {'LIGAR' if valor else 'DESLIGAR'} relay")
    
    def executar_loop(self):
        """Loop principal de leitura"""
        print("\nüåæ FarmTech ESP32 Reader iniciado")
        print("   Pressione Ctrl+C para parar\n")
        
        try:
            while True:
                dados = self.ler_linha()
                
                if dados:
                    self.processar_dados(dados)
                
                time.sleep(0.1)  # 100ms entre leituras
        
        except KeyboardInterrupt:
            print("\n\n‚ö†Ô∏è  Interrup√ß√£o detectada. Salvando dados...")
            self.sensor_mon.salvar_json()
            self.irrigacao_ctrl.salvar_json()
            print("‚úÖ Dados salvos. Encerrando...")


def main():
    """Fun√ß√£o principal"""
    # Ajuste a porta conforme seu sistema
    # Windows: COM3, COM4, etc.
    # Linux/Mac: /dev/ttyUSB0, /dev/tty.usbserial, etc.
    
    reader = ESP32Reader(porta='COM3', baud=115200)
    
    if reader.conectar():
        reader.executar_loop()
    
    reader.desconectar()


if __name__ == "__main__":
    main()
```

---

## üîß Configura√ß√£o do Ambiente

### 1. Instalar PySerial

```bash
pip install pyserial
```

### 2. Identificar Porta Serial

**Windows**:
```powershell
# Gerenciador de Dispositivos ‚Üí Portas (COM e LPT)
# Anote a porta (ex: COM3)
```

**Linux**:
```bash
ls /dev/ttyUSB*
# ou
ls /dev/ttyACM*
```

**Mac**:
```bash
ls /dev/tty.usbserial*
```

### 3. Testar Comunica√ß√£o

```python
import serial
import time

# Substitua 'COM3' pela sua porta
ser = serial.Serial('COM3', 115200, timeout=1)
time.sleep(2)

print("Lendo 10 linhas...")
for i in range(10):
    linha = ser.readline().decode('utf-8').strip()
    print(linha)

ser.close()
```

---

## üìä Fluxo de Dados Completo

### Passo a Passo

1. **ESP32 l√™ sensores** a cada 5 segundos
   - NPK: digitalRead(GPIO 2, 4, 5)
   - pH: analogRead(GPIO 34) convertido
   - Temp/Umid: dht.readTemperature(), dht.readHumidity()

2. **ESP32 envia JSON** via Serial USB (115200 baud)
   ```
   {"cultivo_id":1,"temperatura":26.5,"umidade_ar":50.0,...}
   ```

3. **Python l√™ Serial** com PySerial
   ```python
   dados = json.loads(serial.readline())
   ```

4. **Python registra leitura** no SensorMonitor
   ```python
   leitura_id = sensor_mon.adicionar_leitura(...)
   ```

5. **Python decide irriga√ß√£o** com IrrigacaoController
   ```python
   resultado = irrigacao_ctrl.decidir_irrigacao(cultivo, leitura)
   ```

6. **Python envia comando** de volta ao ESP32
   ```python
   serial.write('{"command":"SET_RELAY","value":1}\n')
   ```

7. **ESP32 aciona relay** (GPIO 18)
   ```cpp
   digitalWrite(RELE_PIN, HIGH);
   ```

---

## üîÑ Sincroniza√ß√£o Bidirecional

### Python ‚Üí ESP32 (Comandos)

| Comando | JSON | A√ß√£o ESP32 |
|---------|------|------------|
| Ligar relay | `{"command":"SET_RELAY","value":1}` | digitalWrite(18, HIGH) |
| Desligar relay | `{"command":"SET_RELAY","value":0}` | digitalWrite(18, LOW) |
| For√ßar leitura | `{"command":"READ_SENSORS"}` | lerSensores() imediato |
| Mudar cultivo | `{"command":"SET_CULTIVO","value":2}` | cultivo_id = 2 |

### ESP32 ‚Üí Python (Dados)

| Tipo | Frequ√™ncia | Conte√∫do |
|------|------------|----------|
| Leitura sensores | 5s | JSON completo com todos sensores |
| Mudan√ßa relay | Instant√¢neo | Status on/off |
| Erro | Sob demanda | Mensagens de erro |

---

## ‚ö†Ô∏è Tratamento de Erros

### Python

```python
try:
    dados = json.loads(linha)
except json.JSONDecodeError:
    print("JSON inv√°lido, ignorando linha")
    return

try:
    leitura_id = sensor_mon.adicionar_leitura(...)
except ValueError as e:
    print(f"Valida√ß√£o falhou: {e}")
    return
```

### ESP32

```cpp
if (Serial.available() > 0) {
    String cmd = Serial.readStringUntil('\n');
    
    if (cmd.length() > 0 && cmd.startsWith("{")) {
        processarComando(cmd);
    }
}
```

---

## üéØ Exemplos de Uso

### Monitoramento Cont√≠nuo

```bash
# Terminal 1: Executa ESP32 Reader
python serial_reader.py

# Terminal 2: Monitora logs em tempo real
tail -f logs/operacoes.log
```

### Teste Manual de Relay

```python
import serial
import json
import time

ser = serial.Serial('COM3', 115200)
time.sleep(2)

# Liga relay
ser.write(b'{"command":"SET_RELAY","value":1}\n')
time.sleep(5)

# Desliga relay
ser.write(b'{"command":"SET_RELAY","value":0}\n')

ser.close()
```

---

*Atualizado: Outubro 2025*  
*FarmTech Solutions - Grupo 59 FIAP*
